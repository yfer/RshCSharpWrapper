using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RshCSharpWrapper
{
    /// <summary>
    /// Поддерживаемые платой функции. 
    /// Взято отсюда: http://rudshel.ru/soft/SDK2/Doc/RSHUNIDRIVER_C_RU/html/_rsh_consts_8h.html#a7d002d179754641063bf0db5344f5866
    /// </summary>
    public enum CAPS : uint
    {
        /// <summary>
        /// Устройство с интерфейсом PCI.
        /// </summary>
        DEVICE_PCI = 0,
        /// <summary>
        /// Устройство с интерфейсом PCI Express.
        /// </summary>
        DEVICE_PCI_EXPRESS = 1,
        /// <summary>
        /// Устройство с интерфейсом USB 1.1.
        /// </summary>
        DEVICE_USB1_1 = 2,
        /// <summary>
        /// Устройство с интерфейсом USB 2.0.
        /// </summary>
        DEVICE_USB2_0 = 3,
        /// <summary>
        /// Устройство с интерфейсом USB 3.0.
        /// </summary>
        DEVICE_USB3_0 = 4,
        /// <summary>
        /// Устройство с интерфейсом Ethernet.
        /// </summary>
        DEVICE_ETHERNET = 5,
        /// <summary>
        /// Устройство имеет синтезатор частоты. 
        /// Синтезатор частоты позволяет плавно изменять частоту дискретизации, в отличие от устройств с делителем частоты, у которых есть некая максимальная частота дискретизации Fmax и кратные ей частоты Fmax/2, Fmax/4 и т.д.
        /// Прим. 
        /// Некоторые устройства с установленным синтезатором частоты НЕ ПОДДЕРЖИВАЮТ возможность произвольного выбора частоты дискретизации. Проверить наличие предопределенного списка поддерживаемых частот можно с помощью RSH_CAPS_DEVICE_FREQUENCY_LIST.
        /// </summary>
        DEVICE_FREQUENCY_SYNTHESIZER = 15,
        /// <summary>
        /// В устройстве установлен программируемый счетчик-таймер Intel 8254.
        /// Используя структуру инициализации RshInitTimer можно задать нестандартный режим сбора данных.
        /// </summary>
        DEVICE_TIMER_8254 = 16,
        /// <summary>
        /// Устройство поддерживает возможность задать произвольный размер блока для каждого измерительного канала.
        /// </summary>
        DEVICE_MEMORY_PER_CHANNEL = 17,
        /// <summary>
        /// Устройство имеет таблицу фиксированных частот квантования.
        /// Список частот дискретизации может быть получен с помощью метода IRshDevice::Get() с параметром RSH_GET_DEVICE_FREQUENCY_LIST.
        /// Прим.
        /// Если у устройства нет таблицы частот, можно получить минимальную и максимальную возможные частоты квантования, используя метод IRshDevice::Get() с параметрами RSH_GET_DEVICE_MIN_FREQUENCY и RSH_GET_DEVICE_MAX_FREQUENCY соответственно.
        /// </summary>
        DEVICE_FREQUENCY_LIST = 18,
        /// <summary>
        /// Устройство имеет таблицу фиксированных размеров.
        /// Список частот дискретизации может быть получен с помощью метода IRshDevice::Get() с параметром RSH_GET_DEVICE_SIZE_LIST
        /// Прим.
        /// Все размеры в таблице размеров приведены на канал, т.е. если используется 2 канала (например), в метод IRshDevice::GetData() нужно передать буфер в два раза большего размера, чем заданное значение параметра инициализации RshInitADC::bufferSize.
        /// Если у устройства нет таблицы размеров, можно получить минимальный и максимальный допустимый размер в отсчетах на канал, используя метод IRshDevice::Get() с параметрами RSH_GET_DEVICE_MIN_SAMPLES_PER_CHANNEL и RSH_GET_DEVICE_MAX_SAMPLES_PER_CHANNEL соответственно.
        /// </summary>
        DEVICE_SIZE_LIST = 19,
        /// <summary>
        /// Устройство имеет цифровые линии для ввода (вывода) данных
        /// Дополнительную информацию о цифровых портах устройства можно получить, используя метод IRshDevice::Get() с параметром RSH_GET_DEVICE_PORT_INFO. Полученная структура RshBoardPortInfo содержит все необходимые данные для организации управления цифровыми вводом/выводом.
        /// </summary>
        DEVICE_HAS_DIGITAL_PORT = 20,
        /// <summary>
        /// Устройство имеет таблицу коэффициентов усиления.
        /// Получить список коэффициентов усиления можно с помощью метода IRshDevice::Get() с параметром RSH_GET_DEVICE_GAIN_LIST. 
        /// При использовании коэффициента усиления отличного от 1.0, входной (или выходной) диапазон устройства делится на этот коэффициент усиления, позволяя более полно задействовать динамический диапазон АЦП при работе со слабыми сигналами.
        /// Например, если устройство имеет входной диапазон 10В и 12 бит, вся шкала от 0 до 4096МЗР соотвествует напряжению от -10 до +10В. Использование коэффициента усиления равного 2 ставит в соответствие тому же диапазону (от 0 до 4096МЗР) напряжение от -5 до +5В, таким образом цена одного МЗР становится в два раза меньше. Правильно выбрав коэффициент усиления, можно более точно измерить слабый сигнал.
        /// </summary>
        DEVICE_GAIN_LIST = 21,
        /// <summary>
        /// Поддерживается установка коэффициента усиления индивидуально для каждого канала.
        /// Список коэффициентов усиления может быть получен с помощью метода IRshDevice::Get() с параметром RSH_GET_DEVICE_GAIN_LIST. 
        /// Устанавливаются коэффиценты усиления в списке RshInitADC::channels структуры инициализации.
        /// Прим.
        /// Большинство устройств поддерживают эту возможность.
        /// </summary>
        DEVICE_GAINS_PER_CHANNEL = 22,
        /// <summary>
        /// Доступна возможность записи предыстории измерения.
        /// Используя поле RshInitMemory::preHistory структуры инициализации, можно задать, какая часть буфера данных будет использована для записи данных "предыстории" (до события синхронизации) и "истории" (после события синхронизации).
        /// Прим.
        /// Параметр "предыстория" актуален только при работе в режиме синхронизации.
        /// </summary>
        DEVICE_PREHISTORY = 23,
        /// <summary>
        /// Устройство поддерживает режим сбора данных с удвоенной частотой дискретизации.
        /// Некоторые из высокочастотных устройств с собственной памятью могут работать в так называемом режиме удвоения частоты. Как правило, на таких устройствах установлено отдельное АЦП для оцифровки каждого канала. Когда устройство работает в обычном режиме, все АЦП работают параллельно, каждое цифрует данные со своего аналогового канала.
        /// В режиме удвоения частоты, 2 АЦП работают с данными одного аналогового канала (для большинства устройств это первый канал, для некоторых устройств можно задать канал, который будет использоваться для удвоения - см. RSH_CAPS_DEVICE_FREE_CHANNEL_SELECT_IN_EXT_MODE).
        /// В результате этого, частота дискретизации (и размер буфера) для этого канала удваивается, и если, к примеру, максимальная частота дискретизации для устройства 1ГГц, в режиме удвоения будет активен ТОЛЬКО один из двух каналов, но с частотой дискретизации 2ГГц. 
        /// Пример:
        /// Для составных устройств (многоканальных осциллографов), в которых используются 2 или более устройства в качестве базовых модулей, число каналов в режиме удвоения будет в два раза меньше, чеи общее число каналов осциллографа.
        /// </summary>
        DEVICE_DOUBLE_FREQUENCY_MODE = 24,
        /// <summary>
        /// Устройство поддерживает режим режим сбора данных с учетверенной частотой дискретизации.
        /// Данный режим аналогичен удвоению частоты (RSH_CAPS_DEVICE_DOUBLE_FREQUENCY_MODE), единственное отличие - частота умножается на 4, а не на 2. Число каналов, соответственно, тоже делится на 4.
        /// </summary>
        DEVICE_QUADRO_FREQUENCY_MODE = 25,
        /// <summary>
        /// Устройство поддерживает режим автокалибровки.
        /// Автоматическая внутренняя калибровка. Процедура калибровки индивидуальна для каждого устройства. Например, плата Леонардо II настраивает уровни смещения нуля при вызове метода IRshDevice::Get() с параметром RSH_GET_DEVICE_AUTO_CALIBRATION_SET.
        /// Прим.
        /// Флаг RSH_CAPS_SOFT_CALIBRATION_IS_AVAILABLE не связан с этим флагом! Наличие RSH_CAPS_SOFT_CALIBRATION_IS_AVAILABLE говорит о том, что в библиотеке устройства присуствуют алгоритмы калибровки, нужные при настройке (предпродажной или ремонтной) устройства.
        /// </summary>
        DEVICE_AUTO_CALIBRATION = 26,
        /// <summary>
        /// Аналоговые каналы устройства могут быть использованы в качестве источника синхронизации.
        /// Используя структуру инициализации RshInitMemory можно задать порог срабатывания, условие перехода (фронт или спад), а также некоторые другие параметры и выбрать один из аналоговых входных каналов устройства в качестве источника синхронизации. После запуска процесса сбора данных с помощью метода IRshDevice::Start(), устройство будет ожидать прихода события синхронизации в соотвествии с заданными параметрами.
        /// </summary>
        DEVICE_SYNCHRO_INTERNAL = 27,
        /// <summary>
        /// Устройство имеет дополнительный вход, который может быть использован в качестве источника синхронизации.
        /// Параметры синхронизации (порог, условие перехода, использование фильтра и др.) могут быть заданы в структуре RshInitMemory. После запуска сбора данных с помощью метода IRshDevice::Start(), устройство будет ожидать прихода события синхронизаци в соотвествии с заданными параметрами.
        /// </summary>
        DEVICE_SYNCHRO_EXTERNAL = 28,
        /// <summary>
        /// Устройство поддерживает возможность внешнего запуска преобразования.
        /// Процесс сбора данных может быть запущен подачей TTL сигнала на определенный цифровой вход устройства. Информация о подключении, уровне сигнала и условиях срабатывания содержится в руководстве пользователя для конкретного устройства.
        /// </summary>
        DEVICE_EXTERNAL_START = 29,
        /// <summary>
        /// Устройство имеет возможность задания уровня гистерезиса для синхронизации.
        /// Некоторые устройства с аппаратной цифровой синхронизацией имеют возможность программно задавать уровень гистерезиса. 
        /// Более подробно об этой фозможности смотрите тут: RshInitMemory::hysteresis.
        /// </summary>
        DEVICE_HYSTERESIS = 30,
        /// <summary>
        /// Устройство имеет отдельный список коэффициентов усиления для входа внешней синхронизации.
        /// Вход внешней синхронизации часто отличается от обычных аналоговых входов, и может иметь свой собственный список коэффициентов усиления. Получить этот список можно используя метод IRshDevice::Get() с параметром RSH_GET_DEVICE_EXT_SYNC_GAINLIST.
        /// Прим.
        /// Если вход внешней синхронизации поддерживает переключение входного сопротивления, можно получить два различных списка коэффициентов усиления для 50Ом и 1МОм режима, используя метод IRshDevice::Get() с константами RSH_GET_DEVICE_EXT_SYNC_GAIN_LIST_50_OHM и RSH_GET_DEVICE_EXT_SYNC_GAIN_LIST_1_MOHM соответственно.
        /// </summary>
        DEVICE_EXT_SYNC_GAIN_LIST = 31,
        /// <summary>
        /// Фильтр низких частот может быть включен для входа внешней синхронизации.
        /// Полоса пропускания, подавление и другие характеристики фильтра зависят от типа устройства, более подробная информация содержится в руководстве пользователя.
        /// Для управления каналом внешней синхронизации используется поле RshInitMemory::channelSynchro структуры RshInitMemory. Для того, чтобы задействовать ФНЧ, нужно выставить бит RshSynchroChannel::FilterLow в поле RshSynchroChannel::control.
        /// </summary>
        DEVICE_EXT_SYNC_FILTER_LOW = 32,
        /// <summary>
        /// Фильтр высоких частот может быть включен для входа внешней синхронизации.
        /// Полоса пропускания, подавление и другие характеристики фильтра зависят от типа устройства, более подробная информация содержится в руководстве пользователя.
        /// Для управления каналом внешней синхронизации используется поле RshInitMemory::channelSynchro структуры RshInitMemory. Для того, чтобы задействовать ФВЧ, нужно выставить бит RshSynchroChannel::FilterHigh в поле RshSynchroChannel::control.
        /// </summary>
        DEVICE_EXT_SYNC_FILTER_HIGH = 33,
        /// <summary>
        /// Доступен режим входного сопротивления 50Ом для входа внешней синхронизации.
        /// Если, кроме того, активен режим RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_1_MOHM, можно программно переключать входное сопротивление входа, используя поле RshInitMemory::channelSynchro структуры RshInitMemory.
        /// Если 50Ом единственная доступная опция, или вообще ни одна из опций неактивна, использование данной настройки не будет иметь эффекта, и вход внешней синхронизации всегда будет в единственном доступном состоянии.
        /// Прим.
        /// При переключении сопротивления входа нужно помнить, что списки коэффициентов усиления различаются для разных входных сопротивлений. Кроме того, некоторые опции (например, возможность использования открытого/закрытого входа) доступны только в режиме 1МОм входа.
        /// </summary>
        DEVICE_EXT_SYNC_INPUT_RESIST_50_OHM = 34,
        /// <summary>
        /// Доступен режим входного сопротивления 1МОм для входа внешней синхронизации.
        /// Если, кроме того, активен режим RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_50_OHM, можно программно переключать входное сопротивление входа, используя поле RshInitMemory::channelSynchro структуры RshInitMemory.
        /// Если 1МОм единственная доступная опция, или вообще ни одна из опций неактивна, использование данной настройки не будет иметь эффекта, и вход внешней синхронизации всегда будет в единственном доступном состоянии.
        /// Прим.
        /// При переключении сопротивления входа нужно помнить, что списки коэффициентов усиления различаются для разных входных сопротивлений. Кроме того, некоторые опции (например, возможность использования открытого/закрытого входа) доступны только в режиме 1МОм входа.
        /// </summary>
        DEVICE_EXT_SYNC_INPUT_RESIST_1_MOHM = 35,
        /// <summary>
        /// Доступна возможность переключения состояния входа внешней синхронизации "Открытый"/"Закрытый".
        /// Если синхровход работает в режиме входного сопротивления 1МОм, есть возможность задать состояние входа: открытый (постоянная составляющая сигнала учитывается) или закрытый (постоянная составляющая сигнала отбрасывается). Для установки параметра используется поле RshInitMemory::channelSynchro структуры RshInitMemory.
        /// </summary>
        DEVICE_EXT_SYNC_COUPLING_AC_DC = 36,
        /// <summary>
        /// Устройство имеет один или несколько ЦАПов.
        /// Управлять ЦАПами можно с помощью метода IRshDevice::Init(), используя структуру инициализации RshInitDAC.
        /// Прим.
        /// Не путайте данную возможность с RSH_CAPS_SOFT_GENERATION_IS_AVAILABLE. Для устройств, которые поддерживают RSH_CAPS_SOFT_GENERATION_IS_AVAILABLE, генерация сигнала является основным предназначением.
        /// Например, устройства серии GSPF имеют внутренний буфер для данных, аттенюатор, возможность выдачи сигнала из внутреннего буфера с различной частотой дискретизации и в разных режимах - одиночный, с повторением, по внешнему триггеру.
        /// Флаг RSH_CAPS_SOFT_INIT_DAC говорит о том, что устройство может, помимо основной своей задачи (сбор и оцифровка данных), выдать сигнал на ЦАП, причем никаких других действий кроме установки заданного уровня сигнала на выходе произвести нельзя.
        /// </summary>
        DEVICE_HAS_DAC_INSTALLED = 37,
        /// <summary>
        /// Устройство имеет возможность подстройки уровня входного напряжения аналоговых каналов.
        /// Обычно, диапазон подстройки уровня входного напряжения совпадает со входным диапазоном канала. Управлять этим параметром можно отдельно для каждого канала в списке RshInitADC::channels, используя поле RshChannel::adjustment.
        /// Допустим, канал имеет входной диапазон ±25В, а на входе синусоидальный сигнал со средним значениме 20В и амплитудой 10В. Без коррекции входного напряжения на входе АЦП будет сигнал от 35В до 10В, и оцифровать его без потерь не получится. Установив же параметр RshChannel::adjustment равным, к примеру, -15В, мы получим на входе АЦП сигнал в диапазоне от 35-15=20В до 10-15=-5В, который может быть оцифрован без потерь.
        /// Прим.
        /// Добиться похожего результата можно, используя режим RshChannel::AC, если флаг RSH_CAPS_DEVICE_INPUT_COUPLING_AC_DC доступен для устройства.
        /// </summary>
        DEVICE_INPUT_LEVEL_ADJUSTMENT = 38,
        /// <summary>
        /// Доступна возможность переключения состояния аналоговых входов "открытый/закрытый".
        /// Если аналоговый канал поддерживает входное сопротивление 1МОм, в этом режиме можно переключать состояние канала между "открытый вход" и "закрытый вход", устанавливая один из флагов (RshChannel::AC или RshChannel::DC) в поле RshChannel::control для выбранного канала в списке RshInitMemory::channels в структуре инициализации RshInitMemory.
        /// </summary>
        DEVICE_INPUT_COUPLING_AC_DC = 39,
        /// <summary>
        /// Доступен режим входного сопротивления 50Ом для аналоговых каналов.
        /// Если, кроме того, активен режим RSH_CAPS_DEVICE_INPUT_RESIST_1_MOHM, можно программно переключать входное сопротивление входа, используя поле RshChannel::control для выбранного канала в списке RshInitMemory::channels структуры RshInitMemory.
        /// Если 50Ом единственная доступная опция, или вообще ни одна из опций неактивна, использование данной настройки не будет иметь эффекта, и вход всегда будет в единственном доступном состоянии.
        /// Прим.
        /// При переключении сопротивления входа нужно помнить, что списки коэффициентов усиления различаются для разных входных сопротивлений. Кроме того, некоторые опции (например, возможность использования открытого/закрытого входа) доступны только в режиме 1МОм входа.
        /// </summary>
        DEVICE_INPUT_RESIST_50_OHM = 40,
        /// <summary>
        /// Доступен режим входного сопротивления 1МОм для аналоговых каналов.
        /// Если, кроме того, активен режим RSH_CAPS_DEVICE_INPUT_RESIST_50_OHM, можно программно переключать входное сопротивление входа, используя поле RshChannel::control для выбранного канала в списке RshInitMemory::channels структуры RshInitMemory.
        /// Если 1МОм единственная доступная опция, или вообще ни одна из опций неактивна, использование данной настройки не будет иметь эффекта, и вход всегда будет в единственном доступном состоянии.
        /// Прим.
        /// При переключении сопротивления входа нужно помнить, что списки коэффициентов усиления различаются для разных входных сопротивлений. Кроме того, некоторые опции (например, возможность использования открытого/закрытого входа) доступны только в режиме 1МОм входа.
        /// </summary>
        DEVICE_INPUT_RESIST_1_MOHM = 41,
        DEVICE_ADC_MODE_SWITCH = 42,
        /// <summary>
        /// Устройство поддерживает режим кадрового сбора.
        /// В этом режиме задаются две частоты:
        /// одна определяет частоту внутри кадра (интервал между данными с разных каналов), а другая - частоту кадров (интервал между блоками данных, в каждом блоке - по одному отсчету с каждого выбранного для измерения канала).
        /// Этот режим полезен при использовании устройства АЦП, каналы которого мультиплексируются (не являются синхронными), с низкой частотой дискретизации. Без включения кадрового режима при использовании низкой частоты дискретизации интервал между каналами будет очень большим. Но если включить данный режим, можно одновнременно получить низкую частоту дискретизации и маленький интервал между измерениями с разных каналов.
        /// </summary>
        DEVICE_FRAME_FREQUENCY_MODE = 43,
        /// <summary>
        /// Устройство поддерживает пакетный режим сбора данных.
        /// Этот режим используется для устройств сбора данных с установленной собственной памятью. Такие устройства собирают данные во внутренний буфер (размер которого может составлять несколько мегабайт), а затем передают эти данные в компьютер по относительном медленным интерфейсам (USB, PCI). Если задан небольшой размер буфера для сбора, основное время уходит не на сбор данных, а на инициализацию сбора и передачу их в компьютер.
        /// Пакетный режим, таким образом, может быть очень полезен: в этом режиме можно задать размер блока данных( поле RshInitMemory::bufferSize) и количество этих блоков (поле RshInitMemory::packetNumber). Очевидно, что итоговый размер, равный bufferSize*packetNumber, должен быть меньше, чем максимальный объем доступной внутренней памяти MaximumMemory (его можно узнать с помощью метода IRshDevice::Get() с параметром RSH_GET_DEVICE_MEMORY_SIZE).
        /// Когда будет запущен процесс сбора данных с помощью метода IRshDevice::Start(), устройство будет собирать данные (используя все заданные параметры сбора, настройки синхронизации и т.д.) до тех пор, пока не соберет RshInitMemory::packetNumber блоков данных. Только после этого начнется передача данных в компьютер. 
        /// Таким образом, можно, например, записать без пропусков несколько быстрых процессов, идущих с небольшим интервалом, что было бы невозможно в обычном режиме.
        /// </summary>
        DEVICE_PACKET_MODE = 44,
        /// <summary>
        /// Сбор данных может быть начат с задержкой (относительно события синхронизации)
        /// Если устройство работает в режиме ожидания события синхронизации, можно задать интервал времени (поле RshInitMemory::startDelay), определяющий задержку старта. Когда будет получено событие синхронизации, запись данных в буфер начнется не мгновенно, а через заданное в поле startDelay время. 
        /// Эта опция, по сути, "предыстория наоборот" (предыстория задается в поле RshInitMemory::preHistory).
        /// </summary>
        DEVICE_START_DELAY = 45,
        /// <summary>
        /// Сбор данных может быть запущен от ведущего устройства.
        /// Задав RshInitADC::Master в качестве источника запуска в поле RshInitADC::startType, можно сделать устройство "ведомым" (slave). После вызова метода IRshDevice::Start(), устройство будет находиться в режиме ожидания (как при использовании синхронизации), и сбор данных начнется только при получении специального сигнала от ведущего (Master) устройства
        /// Прим.
        /// Даная возможность чаще всего применяется в составных системах, где несколько одинаковых устройств используются для синхронного сбора данных. Необходимо соединять ведущее и ведомое (или ведомые) устройства специальным кабелем, чтобы система заработала в таком режиме.
        /// </summary>
        DEVICE_SLAVE_MASTER_SWITCH = 46,
        /// <summary>
        /// Аналоговые каналы устройства - синхронные.
        /// Если данный флаг активен, устройство имеет свой собственный АЦП на каждом из аналоговых каналов, все эти АЦП тактируются из одного источника, и данные со всех каналов собираются синхронно.
        /// Если же верно обратное, устройство имеет только один АЦП и аналоговые каналы оцифровываются по очереди (мультиплексируются). При этом все отсчеты отделены друг от друга по времени на величину 1/F, где F - частота дискретизации.
        /// Прим.
        /// Если устройство не поддерживает данную опцию (каналы не синхронны), максимальная частота дискретизации всегда делится на количество активных (участвующих в сборе данных) каналов. Например, если максимальная частота дискретизации устройства составляет 500кГц, при использовании двух каналов максимально возможное значение частоты в поле RshInitADC::frequency будет равно 250кГц.
        /// </summary>
        DEVICE_SYNCHRO_CHANNELS = 47,
        /// <summary>
        /// АЦП может тактироваться из внешнего источника.
        /// Чтобы включить эту возможность, нужно установить бит RshInitADC::FrequencyExternal в поле RshInitADC::startType структуры инициализации. Можно комбинировать этот режим (используя логическое ИЛИ) с другими флагами, например RshInitADC::Timer, RshInitADC::Internal.
        /// Требования к сигналу (амплитуда, скважность, полярность и пр.) описаны в руководстве пользователя для каждого конкретного устройства.
        /// Прим.
        /// При использовании данной возможности, поле RshInitADC::frequency структуры инициализации все еще актуально (по крайней мере, для большинства устройств), т.к. заданная в нем частота используется для вычисления значения делителя частоты.
        /// Например, если максимальная частота дискретизации устройства составляет 500кГц, в качестве внешней тактовой частоты используется сигнал с частотой 150кГц, а в поле RshInitADC::frequency задана частота 250кГц, при оцифровке будет использовано значение делителя частоты равное 500/250 = 2. Таким образом, получим, что реальная частота дискретизации будет равна 150/2 = 75кГц.
        /// </summary>
        DEVICE_EXTERNAL_FREQUENCY = 48,
        /// <summary>
        /// Доступна возможность переключения частоты дискретизации после получения события синхронизации.
        /// Если доступна данная возможность, можно использовать две разные частоты для "предыстории" и "истории" данных в буфере. Частота предыстории, как правило, некая постоянная величина (иногда доступен выбор из нескольких фиксированных значений).
        /// Включить этот режим работы можно, установив флаг RshInitMemory::FrequencySwitchOn в поле RshInitMemory::controlSynchro структуры инициализации RshInitMemory.
        /// </summary>
        DEVICE_FREQUENCY_SWITCH_PREHISTORY = 49,
        /// <summary>
        /// Можно выбрать канал (каналы), который будут использоваться в режиме удвоения (учетверения) частоты.
        /// Если доступна данная возможность, можно указать, какой канал (или каналы) будет использоваться в режиме удвоения частоты. По умолчанию, всегда используется нулевой канал (или четные каналы, если их количество больше двух). Выбор каналов осуществляется с помощью стандартного флага RshChannel::Used в списке RshInitMemory::channels структуры инициализации.
        /// Прим.
        /// Данная возможность также актуальна и для режима учетверения, за исключением того, что можно выбрать один канал из каждых четырех, а не два, как в режиме удвоения.
        /// </summary>
        DEVICE_FREE_CHANNEL_SELECT_IN_EXT_MODE = 50,
        /// <summary>
        /// Доступна возможность программно переключаться между однополюсным/дифференциальным режимом.
        /// По умолчанию, устроства работают в однополюсном режиме. Чтобы задействовать дифференциальный режим работы, нужно установить флаг RshInitDMA::DiffMode в поле RshInitDMA::control структуры инициализации.
        /// Прим.
        /// При включении дифференциального режима количество каналов становится меньше в два раза, так как оцифровывается разностное напряжение двух входов. Кроме того, требуется выполнить подключение сигналов в соответствии со схемой подключения дифференциальных входов согласно руководству пользователя.
        /// </summary>
        DEVICE_DIFFERENTIAL_INPUT_MODE = 51,
        /// <summary>
        /// Устройство имеет энергонезависимую память (флэш), которая содержит дополнительную информацию.
        /// Наличие данного флага означает, что устройство располагает дополнительной памятью, в которую может быть записан заводской номер платы, различные настроечные коэффициенты и другая информация. Как правило, информация записывается на этапе настройки и в процессе эксплуатации доступна только для чтения.
        /// </summary>
        DEVICE_FLASH_INFO_ONBOARD = 52,
        /// <summary>
        /// Устройство имеет GPS-модуль
        /// Получить данные GPS можно, вызвав метод IRshDevice::Get() с параметром RSH_GET_DEVICE_GPS_DATA или RSH_GET_DEVICE_GPS_DATA_UTF16.
        /// Прим.
        /// Формат строки с данными зависит от устройства и используемого модуля, все подробности приведены в описании устройства.
        /// </summary>
        DEVICE_GPS_MODULE_INSTALLED = 53,
        /// <summary>
        /// Устройство поддерживает режим автоматического запуска
        /// Устройство может быть запрограммировано таким образом, что сбор данных будет запускаться автоматически, с заданным интервалом. Интервал запуска можно задать, используя метод IRshDevice::Get() с параметром RSH_GET_DEVICE_AUTO_START_INTERVAL_SET.
        /// Прим.
        /// Данный режим работы - это НЕ непрерывный режим. Каждый блок данных, получаемый от устройства, независим и не связан с предыдущим. Единственное отличие от стандартного режима "Старт-Стоп" в том, что не нужно запускать сбор каждый раз - устройство будет делать это автоматически.
        /// С программной точки зрения, однако, процесс работы с устройством выглядит очень похожим на работу в непрерывном режиме - нужно задать параметры сбора данных (в том числе и интервал опроса), запустить сбор и затем получать данные длительное время, ожидая событие готовности для каждого собранного буфера. Процесс сбора данных может быть остановлен вызовом метода IRshDevice::Stop().
        /// </summary>
        DEVICE_AUTO_START_MODE = 54,
        /// <summary>
        /// Библиотека абстракции содержит методы для проведения автоматической настройки и калибровки устройства.
        /// Наличие данного флага означает, что устройство может быть откалибровано (настройка внутренних коэффициентов) программно, с использованием внешнего источника сигнала и эталонного измерительного прибора.
        /// Данная возможность не связана с наличием флага RSH_CAPS_DEVICE_AUTO_CALIBRATION (автоматическая подстройка нуля в процессе работы). Режим автоматической калибровки используется только при производстве и ремонте устройств.
        /// </summary>
        SOFT_CALIBRATION_IS_AVAILABLE = 512,
        /// <summary>
        /// Библиотека абстракции содержит методы для осуществления сбора данных в режиме "старт-стоп".
        /// Устройство может быть запрограммировано для сбора данных в режиме "Старт-Стоп". В этом режиме происходит одиночный запуск устройства, сбор одного блока данных с заданными параметрами (частота дискретизации, размер и т.д.) и остановка устройства. Этот сценарий работы является наибоелее распространенным.
        /// </summary>
        SOFT_GATHERING_IS_AVAILABLE = 513,
        /// <summary>
        /// Библиотека абстракции содержит методы для осуществления сбора данных в непрерывном режиме
        /// В этом режиме АЦП запускается один раз, и затем оцифровывает входные сигналы непрерывно, генерируя прерывание каждый раз, когда готова очередная порция данных. Этот процесс может продолжаться долгое время (теоретически, бесконечно) и будет остановлен только при вызове метода IRshDevice::Stop().
        /// Прим.
        /// Из-за аппаратных ограничений по пропускной способности различных интерфейсов, этот режим доступен только для относительно низкочастотных устройств (до 10МГц).
        /// </summary>
        SOFT_PGATHERING_IS_AVAILABLE = 514,
        /// <summary>
        /// Библиотека абстракции содержит методы для управления цифровым портом.
        /// Используя метод IRshDevice::Init() и структуру инициализации RshInitPort можно читать и записывать данные в цифровой порт устройства. Получить информацию о цифровом порте можно, используя метод IRshDevice::Get() с параметром RSH_GET_DEVICE_PORT_INFO.
        /// </summary>
        SOFT_DIGITAL_PORT_IS_AVAILABLE = 515,
        /// <summary>
        /// Библиотека абстракции содержит методы для генерации сигнала.
        /// Используя структуру инициализации RshInitGSPF можно задать параметры генерации сигнала, и затем отправить сформированный буфер данных с сигналом в устройство, используя метод IRshDevice::GetData().
        /// </summary>
        SOFT_GENERATION_IS_AVAILABLE = 516,
        /// <summary>
        /// Структура инициализации RshInitMemory поддерживается библиотекой абстракции.
        /// Использовать эту структуру для передачи параметров можно в методе IRshDevice::Init()
        /// Прим.
        /// Данная структура обычно используется для высокочастотных устройств сбора данных с установленной собственной памятью.
        /// </summary>
        SOFT_INIT_MEMORY = 517,
        /// <summary>
        /// Структура инициализации RshInitDMA поддерживается библиотекой абстракции.
        /// Использовать эту структуру для передачи параметров можно в методе IRshDevice::Init().
        /// Прим.
        /// Данная структура обычно используется для низкочастотных устройств сбора данных. Используя эту структуру, можно организовать сбор данных в непрерывном режиме.
        /// </summary>
        SOFT_INIT_DMA = 518,
        /// <summary>
        /// Структура инициализации RshInitGSPF поддерживается библиотекой абстракции.
        /// Использовать эту структуру для передачи параметров можно в методе IRshDevice::Init().
        /// Прим.
        /// Данная структура используется для программирования устройств серии ГСПФ
        /// </summary>
        SOFT_INIT_GSPF = 519,
        /// <summary>
        /// Структура инициализации RshInitVoltmeter поддерживается библиотекой абстракции.
        /// Использовать эту структуру для передачи параметров можно в методе IRshDevice::Init().
        /// Прим.
        /// Данная структура используется для программирования цифровых вольтметров с интерфейсом VISA.
        /// </summary>
        SOFT_INIT_VOLTMETER = 520,
        /// <summary>
        /// Структура инициализации RshInitTimer поддерживается библиотекой абстракции.
        /// Использовать эту структуру для передачи параметров можно в методе IRshDevice::Init().
        /// Прим.
        /// Данная структура используется для прямого управления программируемым счетчиком-таймером устройства.
        /// </summary>
        SOFT_INIT_TIMER = 521,
        /// <summary>
        /// Библиотека абстракции содержит методы для реализация программного стробоскопа.
        /// Стробоскопирование работает только для периодических сигналов, и при включенной синхронизации. Получая информацию о точном моменте срабатывания синхронизации, можно из нескольких реализации периодического сигнала построить одну, но с более высоким временным разрешением.
        /// </summary>
        SOFT_STROBOSCOPE = 522,
        /// <summary>
        /// Структура инициализации RshInitDAC поддерживается библиотекой абстракции.
        /// Использовать эту структуру для передачи параметров можно в методе IRshDevice::Init().
        /// Прим.
        /// Данная структура используется для управления ЦАПами.
        /// </summary>
        SOFT_INIT_DAC = 523,
        /// <summary>
        /// Структура инициализации RshInitPort поддерживается библиотекой абстракции. 
        /// Использовать эту структуру для передачи параметров можно в методе IRshDevice::Init().
        /// Прим.
        /// Данная структура используется для управления цифровым портом.
        /// </summary>
        SOFT_INIT_PORT = 524,
    }
}
